{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GEIGER Indicator GEIGER is an innovation project that aims to develop a solution that allows small businesses to become aware of their risks related to cybersecurity, data protection, and privacy, and get help in reducing these risks. The project collaborates with security specialists, cyber ranges, and national cybersecurity centres to develop GEIGER, a \u201cGeiger counter\u201d for cybersecurity, which will help small businesses to become aware of cyber threats. A small business can use GEIGER on the web or the smartphone, and it dynamically shows the level of current risks for the company. Seeing high risk allows the user to react immediately and to take simple measures or get help in lowering the risk exposure significantly. The figure as below depicts the overall GEIGER ecosystem. Our focus in this tutorial will be on the GEIGER indicator as shown in the central cloud of the figure. The GEIGER Indicator solution allows users to calculate their GEIGER score , a measure of the cybersecurity risk to which they and their SME are exposed. Based on the characteristics of an SME and the results of the GEIGER Indicator calculation, users receive recommendations for actions to mitigate cybersecurity risk. We have detailed the algorithmic and cybersecurity concepts behind the GEIGER indicator, the data model that facilitates the algorithm, and the translation of these concepts to code. We provided a theoretical grounding to our work in a scientific paper presented at the 2021 International Conference on Availability, Reliability, and Security (ARES). List of GEIGER modules GEIGER Toolbox The GEIGER Toolbox is a tool enabling the user to assess their Cyberthreat exposure and forms an open ecosystem allowing any interested party to extend this tool by adding plugins. GEIGER Storage GEIGER Communication API GEIGER Toolbox UI GEIGER Indicator Cloud There is an additional component named GEIGER Cloud Adapter that will oversee the process of searching and synchronizing data between the GEIGER Toolbox and GEIGER Cloud. Besides, the Cloud Adapter also allows for searching and synchronizing data with the Toolbox Core. GEIGER Cloud Adapter External Plugin The plugins may be added at any time by the user and integrate seamlessly into the framework. No modification on the core application is required to add new indicators of cyber threats, recommendations, or functionalities. They all may be added using project external code. CyberRange (MI) KSP (MI) Chatbot (KPMG)","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"#geiger-indicator","text":"GEIGER is an innovation project that aims to develop a solution that allows small businesses to become aware of their risks related to cybersecurity, data protection, and privacy, and get help in reducing these risks. The project collaborates with security specialists, cyber ranges, and national cybersecurity centres to develop GEIGER, a \u201cGeiger counter\u201d for cybersecurity, which will help small businesses to become aware of cyber threats. A small business can use GEIGER on the web or the smartphone, and it dynamically shows the level of current risks for the company. Seeing high risk allows the user to react immediately and to take simple measures or get help in lowering the risk exposure significantly. The figure as below depicts the overall GEIGER ecosystem. Our focus in this tutorial will be on the GEIGER indicator as shown in the central cloud of the figure. The GEIGER Indicator solution allows users to calculate their GEIGER score , a measure of the cybersecurity risk to which they and their SME are exposed. Based on the characteristics of an SME and the results of the GEIGER Indicator calculation, users receive recommendations for actions to mitigate cybersecurity risk. We have detailed the algorithmic and cybersecurity concepts behind the GEIGER indicator, the data model that facilitates the algorithm, and the translation of these concepts to code. We provided a theoretical grounding to our work in a scientific paper presented at the 2021 International Conference on Availability, Reliability, and Security (ARES).","title":"GEIGER Indicator"},{"location":"#list-of-geiger-modules","text":"","title":"List of GEIGER modules"},{"location":"geiger-risk-score/","text":"GEIGER Risk Score The GEIGER Indicator solution allows users to calculate their GEIGER score, a measure of the cybersecurity risk to which they and their SME are exposed. Based on the characteristics of an MSE and the results of the GEIGER Indicator calculation, users receive recommendations for actions to mitigate cybersecurity risk. The GEIGER Indicator score can be further subcategorized into two scores: Device score and User score, together they form the Global GEIGER score. More precisely, for each GEIGER threat defined, a score is calculated for \u2018User\u2019 and \u2018Device\u2019 based on metrics received from different tools. The GEIGER Indicator contains 4 key points described as below. User/Device Score The User Score describes knowledge of cyber security and weather following recommendations. The Device Score shows the status of the device against threats. Aggregate Score The Aggregate Score is an aggregate score that is average among User, Device score. SME Score The SME Score is for the company. The Company owner only has the MSE score. The MSE Score shows the average of all Employee\u2019s total Score who agreed to share their score to supervisors. Recommendations The recommendation is suitable action for each user based on the type of threats. The users get the installation link of plugins with recommendation.","title":"GEIGER Risk Score"},{"location":"indicator-algorithm/","text":"GEIGER Indicator Algorithm A threat-based cybersecurity risk assessment algorithm must be supported by a data model and data sources that are equally threat- centric. In this section, we describe how a threat-based view of SME cyber-systems produces a data model supporting a threat-based approach to cybersecurity risk assessment. We outline the data required to enable our approach and describe the algorithm that transforms the data into a cybersecurity risk indicator. The goal's of GEIGER indicator provides three score. This figure shows overview of GEIGER scores. The indicator calculate user and device score from each physical device (Android, Windows, IOS etc.) and owner. And the indicator provide the aggregate score based on user and device score on physical device. The aggregate score consist of all physical device which is paired on one of device (main device). The calculation of SME score is only allow company owner (CEO). In this calculation, the indicator calculate SME score using the aggregate score of the paired employees. This calculation is hierarchy as shown on figure.. The supervisor calculate the risk score with employees to aggregate score. The company owner calculate SME score when reach aggregate score of employees under CEO position. The indicator algorithm designed based on threats metric. The organization of cyber security announce priority of threat and risk which is more dangerous nowadays. In GEIGER project, this metric is provided as 'global data' such as ':Global:threat', ':Global:profile', 'Global:recommendation'. This threat impacts consist of three impacts (high, medium, low) about SME actions. The indicator algorithm works based on three factor, positive and negative, countermeasures. In this concept, when user do some action on their physical device it would be effect as positive or negative on indicator algorithm. This figure shows formula of indicator algorithm. This formula support risk score using global data, metrics data. Please refer this paper if you want more detailed information.","title":"GEIGER Indicator Algorithm"},{"location":"data/devices/","text":":Devices :Devices:{deviceUUID} :Devices:{Device_UUID}{ name={en=>\"Samsung Mobile Ana\"}, type={en=>\"mobile\"}, owner={en=>\"328161f6-89bd-49f6-user-5a375ff56ana\"} }","title":":Devices"},{"location":"data/devices/#_1","text":"","title":""},{"location":"data/devices/#devicesdeviceuuid","text":":Devices:{Device_UUID}{ name={en=>\"Samsung Mobile Ana\"}, type={en=>\"mobile\"}, owner={en=>\"328161f6-89bd-49f6-user-5a375ff56ana\"} }","title":":Devices:{deviceUUID}"},{"location":"data/enterprise/","text":":Enterprise Enterprise node is not only limited to user-specific and device-specific information but also enterprise-specific information, mainly the risk profile associated with the SME (digitally dependent, digital enabler, and digitally based). These nodes are used as a metric to calculate GEIGER aggregate score. Detailed content described Section 3.1.4.2 in D1.2. :Enterprise{ \"name\"=[ en=>\"University of Aplied Sciences Northwestern Switzerland\", de=>\"Fachhochschule Nordwestschweiz\" ], \"associatedProfiles\"=[\"Digitally based\" or \"Digitally enabler\u201d or \u201cdigitally dependent\u201d] \"location\"=[\"UUID of location\"], \"sector\"=[Example], :Enterprise:Users:{User_UUID} :Enterprise:users:{User_UUID}{ \"name\"=[\"Example\"], \"firstname\"=[\"Loredana\"], \"UUIDs\"=[\"44e128a5-ac7a-4c9a-be4c-224b6bf81b20,44e128a5-ac7a-4c9a-be4c-224b6bf81b21\"], \"mainUser\"=[\"1\"], \"KnowledgeLevel\"=[\"1\"] }","title":":Enterpise"},{"location":"data/enterprise/#_1","text":"","title":""},{"location":"data/enterprise/#enterprise","text":"Enterprise node is not only limited to user-specific and device-specific information but also enterprise-specific information, mainly the risk profile associated with the SME (digitally dependent, digital enabler, and digitally based). These nodes are used as a metric to calculate GEIGER aggregate score. Detailed content described Section 3.1.4.2 in D1.2. :Enterprise{ \"name\"=[ en=>\"University of Aplied Sciences Northwestern Switzerland\", de=>\"Fachhochschule Nordwestschweiz\" ], \"associatedProfiles\"=[\"Digitally based\" or \"Digitally enabler\u201d or \u201cdigitally dependent\u201d] \"location\"=[\"UUID of location\"], \"sector\"=[Example],","title":":Enterprise"},{"location":"data/enterprise/#enterpriseusersuser_uuid","text":":Enterprise:users:{User_UUID}{ \"name\"=[\"Example\"], \"firstname\"=[\"Loredana\"], \"UUIDs\"=[\"44e128a5-ac7a-4c9a-be4c-224b6bf81b20,44e128a5-ac7a-4c9a-be4c-224b6bf81b21\"], \"mainUser\"=[\"1\"], \"KnowledgeLevel\"=[\"1\"] }","title":":Enterprise:Users:{User_UUID}"},{"location":"data/geiger-score/","text":"GEIGER Score Nodes GeigerScoreUser :Users:{userUUID}:{indicatorUUID}:data:GeigerScoreUser :Users:772df149-0226-450b-8c7a-de938dfaea03:1234-1234-1234:data:GeigerScoreUser{ GEIGER_score={en=>\"47.78946694003076\"}, threats_score={en=>\"threatUUID,score; \u2026. \"}, number_metrics={en=>\"7\"}, implementedRecommendations={en=>\"\"} } GeigerScoreDevice :Devices:{userUUID}:{indicatorUUID}:data:GeigerScoreDevice : Devices:92ebe4bf-65d2-4106-8445-0a539fc85ec9:1234-1234-1234:data: GeigerScoreDevice{ GEIGER_score={en=>\"62.25655561250642\"}, threats_score={en=>\"threatUUID,score; \u2026. \"}, number_metrics={en=>\"5\"}, implementedRecommendations={en=>\"\"} } GeigerScoreAggregate :Users:{userUUID}:{indicatorUUID}:data:GeigerScoreAggregate :Users:772df149-0226-450b-8c7a-de938dfaea03:1234-1234-1234:data:GeigerScoreAggregate{ GEIGER_score={en=>\"47.78946694003076\"}, threats_score={en=>\"threatUUID,score; \u2026. \"}, number_metrics={en=>\"10\"}, } GeigerSMEScore :Users:{userUUID}:{indicatorUUID}:data:GeigerSMEScore :Users:772df149-0226-450b-8c7a-de938dfaea03:1234-1234-1234:data:GeigerSMEScore{ associatedProfiles={en=>\"digitally based\"}, GEIGER_score={en=>\"59.18799727912817\"}, location={en=>\"ce82b724-b62a-4mse-9loc-aa7c4755e6CH\"}, sector={en=>\"Hair-Dresser\"} }","title":"geigerScore"},{"location":"data/geiger-score/#_1","text":"","title":""},{"location":"data/geiger-score/#geigerscoreuser","text":":Users:{userUUID}:{indicatorUUID}:data:GeigerScoreUser :Users:772df149-0226-450b-8c7a-de938dfaea03:1234-1234-1234:data:GeigerScoreUser{ GEIGER_score={en=>\"47.78946694003076\"}, threats_score={en=>\"threatUUID,score; \u2026. \"}, number_metrics={en=>\"7\"}, implementedRecommendations={en=>\"\"} }","title":"GeigerScoreUser"},{"location":"data/geiger-score/#geigerscoredevice","text":":Devices:{userUUID}:{indicatorUUID}:data:GeigerScoreDevice : Devices:92ebe4bf-65d2-4106-8445-0a539fc85ec9:1234-1234-1234:data: GeigerScoreDevice{ GEIGER_score={en=>\"62.25655561250642\"}, threats_score={en=>\"threatUUID,score; \u2026. \"}, number_metrics={en=>\"5\"}, implementedRecommendations={en=>\"\"} }","title":"GeigerScoreDevice"},{"location":"data/geiger-score/#geigerscoreaggregate","text":":Users:{userUUID}:{indicatorUUID}:data:GeigerScoreAggregate :Users:772df149-0226-450b-8c7a-de938dfaea03:1234-1234-1234:data:GeigerScoreAggregate{ GEIGER_score={en=>\"47.78946694003076\"}, threats_score={en=>\"threatUUID,score; \u2026. \"}, number_metrics={en=>\"10\"}, }","title":"GeigerScoreAggregate"},{"location":"data/geiger-score/#geigersmescore","text":":Users:{userUUID}:{indicatorUUID}:data:GeigerSMEScore :Users:772df149-0226-450b-8c7a-de938dfaea03:1234-1234-1234:data:GeigerSMEScore{ associatedProfiles={en=>\"digitally based\"}, GEIGER_score={en=>\"59.18799727912817\"}, location={en=>\"ce82b724-b62a-4mse-9loc-aa7c4755e6CH\"}, sector={en=>\"Hair-Dresser\"} }","title":"GeigerSMEScore"},{"location":"data/global/","text":":Global The \u201cGlobal data\u201d contains sub-nodes with globally available information (e.g., a common threat list). It is fed by Local Data Storage or the cloud connector depend on the GEIGER toolbox option either Local only or Cloud. More information regarding the \u201cGlobal Data\u201d and the motivation behind the need of acquiring such data for calculating the GEIGER score can be found in Deliverable D1.2 . This figure describes how to design the GEIGER threat from threats list. The concept of GEIGER risk score is based on threats so the designing threats is important. The GEIGER threat designed by cyber security organzation it would be delivered by CERT. So, the mapping is required between normal threats and GEIGER threat . The GEIGER threat defined on :Global:profiles . The external plugin (e.g, anti virous tool, educational tool etc.) have to send the validated threat uuid on their metric data refer :Global:threat and :Global:profiles . :Global:threat The \u201c:Global:threat\u201d node includes the name, type of threat and description. The GEIGER global threat is unique designed by GEIGER cloud. It is 12 now (16,Aug,2022). Therefore, the geigerThreat can be same and duplicate with other nodes. But, UUID of GEIGER global threat defined on 'Global:profiles' node. :Global:threats:80efffaf-98a1-4e0a-8f5e-th89388368cj{[ \"name\"=[en=>\"Cryptojacking\"], \"geigerThreat\"=[en=>\"Malware\"], \"description\"=[en=>\"Threat description\"] ]} :Global:profiles The \u201c:Global:profiles\u201d node includes the risk profile weights for each different SME profile (digitally dependent, digital enabler, and digitally based). The risk profile weights are used as a metric to calculate GEIGER total score. :Global:Profiles:3e88c7b7-5bdb-4503-b963-f36333e0224f:{ \"name\":[\"Digitally based\" or \"Digitally enabler\u201d or \u201cdigitally dependent\u201d], \"threat1_UUID\"=[\"0.1\"], \"threatN_UUID\"=[\"0.8\"] } :Global:recommendation The \u201c:Global:recommendation\u201d node has two main cyber-systems \u2018User\u2019 and \u2018Device\u2019 and it outputs a score and recommendations threat in each cyber system. The indicator refers to this node when calculating GEIGER recommendation nodes for each threat. Detailed content described Section 3.1.3.4 in D1.2. :Global:Recommendations:e430cb4e-dcf4-4169-b0d3-94ea3a3df528{ short=[\"short desciption\"], long=[\"long description\"], Action=[\"geiger://mainRecommender/12371284376t21\"], relatedThreatsWeights=[\"threat1_UUID,Low;...;threatN_UUID,Meduim\"], costs=[\"False\"], RecommendationType=[\"Device\"] }","title":":Global"},{"location":"data/global/#_1","text":"","title":""},{"location":"data/global/#globalthreat","text":"The \u201c:Global:threat\u201d node includes the name, type of threat and description. The GEIGER global threat is unique designed by GEIGER cloud. It is 12 now (16,Aug,2022). Therefore, the geigerThreat can be same and duplicate with other nodes. But, UUID of GEIGER global threat defined on 'Global:profiles' node. :Global:threats:80efffaf-98a1-4e0a-8f5e-th89388368cj{[ \"name\"=[en=>\"Cryptojacking\"], \"geigerThreat\"=[en=>\"Malware\"], \"description\"=[en=>\"Threat description\"] ]}","title":":Global:threat"},{"location":"data/global/#globalprofiles","text":"The \u201c:Global:profiles\u201d node includes the risk profile weights for each different SME profile (digitally dependent, digital enabler, and digitally based). The risk profile weights are used as a metric to calculate GEIGER total score. :Global:Profiles:3e88c7b7-5bdb-4503-b963-f36333e0224f:{ \"name\":[\"Digitally based\" or \"Digitally enabler\u201d or \u201cdigitally dependent\u201d], \"threat1_UUID\"=[\"0.1\"], \"threatN_UUID\"=[\"0.8\"] }","title":":Global:profiles"},{"location":"data/global/#globalrecommendation","text":"The \u201c:Global:recommendation\u201d node has two main cyber-systems \u2018User\u2019 and \u2018Device\u2019 and it outputs a score and recommendations threat in each cyber system. The indicator refers to this node when calculating GEIGER recommendation nodes for each threat. Detailed content described Section 3.1.3.4 in D1.2. :Global:Recommendations:e430cb4e-dcf4-4169-b0d3-94ea3a3df528{ short=[\"short desciption\"], long=[\"long description\"], Action=[\"geiger://mainRecommender/12371284376t21\"], relatedThreatsWeights=[\"threat1_UUID,Low;...;threatN_UUID,Meduim\"], costs=[\"False\"], RecommendationType=[\"Device\"] }","title":":Global:recommendation"},{"location":"data/local/","text":":Local The \u201c:Local\u201d node is the UUID of the currently logged-in user and the current device in use. The GEIGER indicator uses UUID on node path to get, create and update node data. It is certain that some users might have more than one device paired with their GEIGER account, a score is calculated for each device, however detailed GEIGER threats scores are only shown for the current device in use. :Local{ currentUser=[\"44e128a5-ac7a-4c9a-be4c-224b6bf81b20\"], currentDevice=[\"123e4567-e89b-42d3-a456-556642440000\"] } :Local:plugin The \u201c:Local: plugin\u201d node contains the name of plugin, company. The plugin creates this node to LDS using GEIGER API. The indicator access sensor value nodes used this information (e.g., company UUID). :Local:plugin:$CompanyUUID{ name={en=>\"ATOS RAE\"}, company={en=>\"ATOS\"} }","title":":Local"},{"location":"data/local/#_1","text":"","title":""},{"location":"data/local/#local","text":"The \u201c:Local\u201d node is the UUID of the currently logged-in user and the current device in use. The GEIGER indicator uses UUID on node path to get, create and update node data. It is certain that some users might have more than one device paired with their GEIGER account, a score is calculated for each device, however detailed GEIGER threats scores are only shown for the current device in use. :Local{ currentUser=[\"44e128a5-ac7a-4c9a-be4c-224b6bf81b20\"], currentDevice=[\"123e4567-e89b-42d3-a456-556642440000\"] }","title":":Local"},{"location":"data/local/#localplugin","text":"The \u201c:Local: plugin\u201d node contains the name of plugin, company. The plugin creates this node to LDS using GEIGER API. The indicator access sensor value nodes used this information (e.g., company UUID). :Local:plugin:$CompanyUUID{ name={en=>\"ATOS RAE\"}, company={en=>\"ATOS\"} }","title":":Local:plugin"},{"location":"data/recommendation/","text":"GEIGER Recommendation Nodes The indicator suggests recommendations as checking impact between threat and recommendation. The user can select to accept the recommendation or not to determine the Implemented recommendation. User Recommendations :Users:{userUUID}:{indicatorUUID}:data:recommendations :Users:1ec418f3-f581-4ad6-9005-78ba8acd0552:1234-1234-1234:data:recommendations{ threatUUID={en=>\"recommendationUUID,Impact;\u2026\"}, 80efffaf-98a1-4e0a-8f5e-gr89388354sp={en=>\"123e4567-e89b-42d3-a4us-556642440rec-003,1.0;123e4567-e89b-42d3-a4us-556642440rec-019,0.1;123e4567-e89b-42d3-a4us-556642440rec-006,1.0;123e4567-e89b-42d3-a4us-556642440rec-001,1.0;\"}, \u2026 } Device Recommendations :Devices:{userUUID}:{indicatorUUID}:data:recommendations :Devices:92ebe4bf-65d2-4106-8445-0a539fc85ec9:1234-1234-1234:data:recommendations{ threatUUID={en=>\"recommendationUUID,Impact;\u2026\"}, 80efffaf-98a1-4e0a-8f5e-gr89388353wa={en=>\"123e4567-e89b-42d3-a4dv-556642440rec-027,1.0;123e4567-e89b-42d3-a4dv-556642440rec-002,0.5;\"}, \u2026 }","title":"geigerRecommendation"},{"location":"data/recommendation/#_1","text":"","title":""},{"location":"data/recommendation/#user-recommendations","text":":Users:{userUUID}:{indicatorUUID}:data:recommendations :Users:1ec418f3-f581-4ad6-9005-78ba8acd0552:1234-1234-1234:data:recommendations{ threatUUID={en=>\"recommendationUUID,Impact;\u2026\"}, 80efffaf-98a1-4e0a-8f5e-gr89388354sp={en=>\"123e4567-e89b-42d3-a4us-556642440rec-003,1.0;123e4567-e89b-42d3-a4us-556642440rec-019,0.1;123e4567-e89b-42d3-a4us-556642440rec-006,1.0;123e4567-e89b-42d3-a4us-556642440rec-001,1.0;\"}, \u2026 }","title":"User Recommendations"},{"location":"data/recommendation/#device-recommendations","text":":Devices:{userUUID}:{indicatorUUID}:data:recommendations :Devices:92ebe4bf-65d2-4106-8445-0a539fc85ec9:1234-1234-1234:data:recommendations{ threatUUID={en=>\"recommendationUUID,Impact;\u2026\"}, 80efffaf-98a1-4e0a-8f5e-gr89388353wa={en=>\"123e4567-e89b-42d3-a4dv-556642440rec-027,1.0;123e4567-e89b-42d3-a4dv-556642440rec-002,0.5;\"}, \u2026 }","title":"Device Recommendations"},{"location":"data/sensor-values/","text":"Senser Values As explained in D1.2, sensor values related to each cyber system \u2018User\u2019 or \u2018Device\u2019, either positively or negatively. In other words, the sensor values sent by different tools can either contribute in a positive way and improve the \u2018User\u2019 or \u2018Device\u2019 score by decreasing the overall risk or contribute negatively and worsen the score. Additionally, each tool sends one or more sensor values, where each value relates to a specific GEIGER threat(s) with a specific impact either low, medium, or high. More information regarding tools and sensor value can be found in D1.2 and D2.1. Device metrics :Devices:{deviceUUID}:{companyUUID}:data:metrics:{metricUUID} :Devices:device_UUID:company_UUID:data:metrics:metric_UUID{ name=[\"numberOfInstalledApps\"], minValue=[\"0\"], maxValue=[\"200\"], value:Geigervalue=[\"65\"], valueType=[\"int\"], relation=[\"user\"], threatsImpact=[\"afde4567-e89b-e2d3-e456-556642569800\",\"low\";\"afdd4567-e89b-42d3-a456-556642fe000a\",\"high\"], flag=[\"0\"] } User metrics :Users:{userUUID}:{companyUUID}:data:metrics:{metricUUID} :Users:user_UUID:company_UUID:data:metrics:metric_UUID{ name=[\"numberOfInstalledApps\"], minValue=[\"0\"], maxValue=[\"200\"], value:Geigervalue=[\"65\"], valueType=[\"int\"], relation=[\"user\"], threatsImpact=[\"afde4567-e89b-e2d3-e456-556642569800\",\"low\";\"afdd4567-e89b-42d3-a456-556642fe000a\",\"high\"], flag=[\"0\"] }","title":"sensor values"},{"location":"data/sensor-values/#_1","text":"","title":""},{"location":"data/sensor-values/#device-metrics","text":":Devices:{deviceUUID}:{companyUUID}:data:metrics:{metricUUID} :Devices:device_UUID:company_UUID:data:metrics:metric_UUID{ name=[\"numberOfInstalledApps\"], minValue=[\"0\"], maxValue=[\"200\"], value:Geigervalue=[\"65\"], valueType=[\"int\"], relation=[\"user\"], threatsImpact=[\"afde4567-e89b-e2d3-e456-556642569800\",\"low\";\"afdd4567-e89b-42d3-a456-556642fe000a\",\"high\"], flag=[\"0\"] }","title":"Device metrics"},{"location":"data/sensor-values/#user-metrics","text":":Users:{userUUID}:{companyUUID}:data:metrics:{metricUUID} :Users:user_UUID:company_UUID:data:metrics:metric_UUID{ name=[\"numberOfInstalledApps\"], minValue=[\"0\"], maxValue=[\"200\"], value:Geigervalue=[\"65\"], valueType=[\"int\"], relation=[\"user\"], threatsImpact=[\"afde4567-e89b-e2d3-e456-556642569800\",\"low\";\"afdd4567-e89b-42d3-a456-556642fe000a\",\"high\"], flag=[\"0\"] }","title":"User metrics"},{"location":"imple/flowchart/","text":"Flow Chart Figure 12 shows the flow chart of Indicator as how to provide GEIGER score for threat of SMEs. The indicator checks the master node of LDS using GEIGER API to synchronize GEIGER toolbox (Step. 1). The current user and device UUID require access to necessary nodes to calculate (Step. 2). Setup the listener to get a notification of data events using LDS API (Step. 3) and then Preparing the threat data to use on the GEIGER algorithm (Step. 4). Before starting to calculate the GEIGER score, check the existing GEIGER score nodes in LDS for creation or update (Step. 5). These works as upper are initial work on GEIGER Indicator workflow. Now, to calculate GEIGER score as a threat for SMEs, the indicator waits for the metric nodes (\u201cdata:metric\u201d) on LDS and uses a listener and checks if it exists (Step. 6). Finally, The GEIGER score nodes store to LDS and then check the existence of the enterprise nodes for calculation of GEIGER MSE nodes (Step. 7).","title":"Flowchart"},{"location":"imple/source-code/","text":"Source Code The implementation of GEIGER Cybersecurity Risk Indicator develop using Dart and Flutter. The GEIGER Indicator aim to support cross platform, so the Dart and Flutter is good option that provide compiling for several operating system such as Android, IOS, Windows etc. pud.dev Github \u2699\ufe0f pubspec.yaml Read the GEIGER Indicator Build configuration is stored in .pubspec.yaml . This is dart/flutter standard. Add your own configurations here, such as extensions. Remember that many extensions and additional Dart packages to be installed. \ud83d\udcda lib/src/ All source code of GEIGER Indicator lives in lib/src , it was generated using Dart defaults. All the *.dart make up sections in the documentation. \ud83d\udca1 ../init.dart It consist of initial function to get and check exist data. ( physics user/device UUID, global/score data ) \ud83d\udca1 ../listener.dart Setting the listener using Storage API and manage the notification of metric data (e.g, sensor value , implemented recommendation etc.). \ud83d\udca1 ../sensors_data.dart Manage the sensor values (e.g, check exist data and update new sensor value etc.). \ud83d\udca1 ../variables.dart Include all core values of GEIGER indicator (e.g, global data , score data , storage api , node path etc.). \ud83d\udca1 lib/src/score/ Related calculation of score ( user score , device score , aggregate score , SME score ). \ud83d\udca1 ../aggregate_score.dart Calculate aggregate score based on indicator algorithm with pairing data. \ud83d\udca1 ../geiger_score.dart Calculate and manage user/device/aggregate score nodes based on indicator algorithm . \ud83d\udca1 ../sme_score.dart Calculate and manage SME score based on indicator algorithm with pairing data. \ud83d\udca1 lib/src/globaldata/ Related mapping and pre-calculation data for risk score calculation ( global threat , global recommendation , global profile ). \ud83d\udca1 ../global_profile.dart Mapping and parsing global profile (company type) for risk score calculation. \ud83d\udca1 ../global_recommendation.dart Calculate, mapping and parsing global recommendation for risk score calculation. \ud83d\udca1 ../global_threat.dart Mapping and parsing global threat (unique) based on global profile for risk score calculation. \ud83d\udccd lib/indicator.dart The main function 'runIndicator' is in this source code. who want to use GEIGER indicator, import this file and call main function. \ud83d\udcdc README.md Contents of this README.md are visible on Github and included on the documentation index page (Don\\'t Repeat Yourself). \u2049\ufe0f Questions / comments If you have questions related to this example, feel free to can ask them as a Github issue here . Read the Docs tutorial To get started with Read the Docs, you may also refer to the Read the Docs tutorial . It provides a full walk-through of building an example project similar to the one in this repository. Author JongGwan An (kman3212@gmail.com)","title":"Source Code"},{"location":"imple/source-code/#read-the-docs-tutorial","text":"To get started with Read the Docs, you may also refer to the Read the Docs tutorial . It provides a full walk-through of building an example project similar to the one in this repository.","title":"Read the Docs tutorial"},{"location":"imple/source-code/#author","text":"JongGwan An (kman3212@gmail.com)","title":"Author"},{"location":"imple/system-architecture/","text":"System Architecture Figure 11 depicts the system architecture of the GEIGER indicator. It consists of three main modules. From a GEIGER Indicator perspective, all data is collected from the Local Data Storage (LDS) using LDS API, Listener. The output of the GEIGER Indicator is stored in the LDS. The LDS listener notify the events of nodes (Create or Update) to GEIGER Indicator (Step. 1). The Listener of Indicator delivers the metric data selected though node path to core module (Step. 2). The Indicator Core calculates GEIGER score using Indicator Algorithm and sends the results to the storage connector (Step. 3). Finally, the storage connector update GEIGER score node used results on LDS (Step. 4).","title":"System Architecture"},{"location":"testcase/1-accessLDS/","text":"Access Local Data Storage given add geiger_api package on pubspec.yaml . when call getGeigerApi() function to get the instance of Local Storage using geiger_api then return instance of geiger api and get Master Local Storage to access GEIGER data. final localMaster = (await getGeigerApi(\"\", GeigerApi.masterId, Declaration.doNotShareData))!; var controller = localMaster.storage;","title":"Get instance of Local Data Storage"},{"location":"testcase/2-getuuid/","text":"Get current user and device UUID on physical device given prepared Local Data Storage instance to access Local Data Storage. when call initStorageController() function to get current User, Device UUID. then get current user UUID , device UUID on physic device. ///initialize instance of controller ///access LDS on current device (android, windows etc) Future initStorageController() async{ final localMaster = (await getGeigerApi(\"\", GeigerApi.masterId, Declaration.doNotShareData))!; controller = localMaster.storage; }","title":"Get current user and device UUID"},{"location":"testcase/3-mapping/","text":"Mapping global threat to GEIGER threat with global profiles (company type) given prepared Local Data Storage instance to access Local Data Storage. when call generateThreats() function to mapping normal threats to geiger threats (12). then get normal threats from :Global:threats node. parsing and mapping to threats data to Map<key,value> in variables.dart referred :Global:profiles . ///Parsing ':Global:threats' Node ///Normal threats -> GEIGER threats (12) ///GEIGER threats (12) defined by CERT Future generateThreats() async { try { var globalThreats = await Storage.controller.get(':Global:threats'); var nodesCsv = await globalThreats.getChildNodesCsv(); if(nodesCsv.isNotEmpty) { ///get all threat nodes var getChildren = await globalThreats.getChildren(); var threatsIterator = getChildren.entries.iterator; ///To makes threat uuid list ///this uuid use on map as key var uuidThreats = nodesCsv.toString().split(','); logger.d('uuidThreats => ${uuidThreats.toString()}'); var uuidIterator = uuidThreats.iterator; CoreValues.uuidThreats = uuidThreats; ///loop threats while (threatsIterator.moveNext()) { uuidIterator.moveNext(); var threatNameNode = await threatsIterator.current.value.getValue('name'); var threatName = threatNameNode!.getValue('en'); var geigerThreatNameNode = await threatsIterator.current.value.getValue('GEIGER_threat'); //geigerThreat var geigerThreatName = geigerThreatNameNode!.getValue('en'); ///Making the threat maps CoreValues.threatUUIDThreatName[uuidIterator.current] = threatName; CoreValues.threatNameThreatUUID[threatName] = uuidIterator.current; CoreValues.threatUUIDGeigerName[uuidIterator.current] = geigerThreatName; if(!CoreValues.geigerNameThreatUUID.containsKey(geigerThreatName)){ CoreValues.geigerNameThreatUUID[geigerThreatName] = []; CoreValues.geigerNameThreatUUID[geigerThreatName].add(uuidIterator.current); }else{ CoreValues.geigerNameThreatUUID[geigerThreatName].add(uuidIterator.current); } } } }catch(e) { logger.e('generateThreats ${e.toString()}'); } }","title":"Mapping threats"},{"location":"testcase/4-checkdataexist/","text":"Check Risk score data exist given prepared Local Data Storage instance to access Local Data Storage. when call checkExistNodes function to check the GEIGER data. then get current user UUID , device UUID on physic device. parsing and mapping :Global:threats data. check exist geiger score node on Local Data Storage. ///check indicator nodes whether exist or not ///geiger score node ///which is created by indicator Future checkExistNodes() async { await isExistParentNode(Types.userScoreNodePath); await isExistParentNode(Types.deviceScoreNodePath); await isExistParentNode(Types.enterpriseScoreNodePath); await getExistScoreNodes(Types.userScoreNodePath, Types.geigerScoreUser,Types.users); await getExistScoreNodes(Types.deviceScoreNodePath, Types.geigerScoreDevice,Types.devices); await getExistScoreNodes(Types.userScoreNodePath, Types.recommendations,Types.users); await getExistScoreNodes(Types.deviceScoreNodePath, Types.recommendations,Types.devices); await getExistScoreNodes(Types.userScoreNodePath, Types.geigerScoreAggregate,Types.users); await getExistScoreNodes(Types.enterpriseScoreNodePath,Types.geigerScoreMSE,''); }","title":"Check risk score nodes exist"},{"location":"testcase/5-setupListener/","text":"Set up Storage Listener given prepared Local Data Storage instance to access Local Data Storage. when call the setValueListener() function to register the specific node to receive notification . then call the registerListener() function with callback function, path and primary key(attribute name). ///Set the trigger to get data for calculation using Local Storage Listener Future setValueListener() async{ ///To receive Metric data (Positive, Negative) ///The calculation algorithm consist of positive, negative and countermeasures) await registerListener(Listener.indicatorListener, Types.userNode,'GEIGERvalue'); await registerListener(Listener.indicatorListener, Types.deviceNode,'GEIGERvalue'); ///To receive Implemented recommendations from UI ///This data effect to risk score as Positive metric ///And effect to each threats score which is related Implemented Recommendations await registerListener(Listener.indicatorListener, Types.userNode,'implementedRecommendations'); await registerListener(Listener.indicatorListener, Types.deviceNode,'implementedRecommendations'); ///To receive dynamic recommendations from external plugin ///Chatbot, KSP provide their onw recommendation await registerListener(Listener.indicatorListener, Types.deviceNode,'pluginName'); ///To receive Pairing information ///It include device, employee paring and it used on aggregate score and MSE score await registerListener(Listener.indicatorListener, ':' + Types.enterprise + ':Users:' + Storage.userUUID,'sharedGeigerScore'); } ///Register Listener based on path, Value using Local Storage Listener Future registerListener(var l, var path, var type) async{ ///Register parent path of target Node SearchCriteria s = SearchCriteria(searchPath: path); ///Set specific attribute of target Node s.nodeValueKey = type; Storage.controller.registerChangeListener(l, s); logger.d(s); }","title":"Set up Storage Listener"},{"location":"testcase/6-gettingMetric/","text":"Getting metric data (Sensor Value, Recommendation) given prepared Local Data Storage instance to access Local Data Storage. registered specific node (metrics) to received new data from Local Data Storage. when Occurring creation or update on node registered subscription by Storage Listener . then delivered new data node to gotStorageChange callback function. checked new data node based on each conditions call updateData() function to parsing and calculate risk score. ///Received metric data using Storage Listener @override void gotStorageChange(EventType event, Node? oldNode, Node? newNode) async { logger.i('new event from =>> ${newNode!.owner} ${newNode.path} '); ///'owner' is ID /// Should compare the owner as me /// Avoid infinite recursion loop by indicator own if(newNode.owner != Types.owner){ ///get metrics from external plugin if(newNode.path.contains(':data:metrics') && newNode.name != 'metrics' ){ logger.i('got event metrics => ${newNode.path}'); //await Future.delayed(const Duration(milliseconds: 1000)); Storage.getValuePath.add(newNode.parentPath); await updateData(newNode); } ..... } } ------------------------------ ///Update risk score as latest ///Refer latest metrics from external plugins Future updateData(Node? metricNode) async{ try { ///split entire path using ':' ///':~:~:~:....' ///path List [0] => '' ///path LIst [1] => Users or Devices etc. ///... var pathList = metricNode!.path.toString().split(':'); var type = ''; var nodePath = ''; var nodeName = ''; ///Set metrics type, path and name if(pathList[1] == Types.users){ type =Types.users; nodePath = Types.userScoreNodePath; nodeName = Types.geigerScoreUser; }else{ type =Types.devices; nodePath = Types.deviceScoreNodePath; nodeName =Types.geigerScoreDevice; } ///Check metric value (GEIGERvalue) whether exist or not if((await metricNode.getValue('GEIGERvalue')) != null) { //await clearPN(); await updateMetrics(type, metricNode); await updateScoreNode(nodePath,nodeName,type); await updateRecommendationNode(nodePath,Types.recommendations,type); await aggregateScore(); }else{ logger.i('updateMetrics $metricNode GEIGERvalue is not existed'); return; } }catch(e){ logger.e(e); } }","title":"Getting metrics data"},{"location":"testcase/7-gettingPairingdata/","text":"Getting pairing data (Devices, Employees) given prepared Local Data Storage instance to access Local Data Storage. registered specific node (pairing) to received new data from Local Data Storage. when Occurring creation or update on node registered subscription by Storage Listener . then delivered new data node to gotStorageChange callback function. checked new data node based on each conditions call getScoreAll() function to parsing and calculate risk score. ///Received metric data using Storage Listener @override void gotStorageChange(EventType event, Node? oldNode, Node? newNode) async { logger.i('new event from =>> ${newNode!.owner} ${newNode.path} '); ///'owner' is ID /// Should compare the owner as me /// Avoid infinite recursion loop by indicator own if(newNode.owner != Types.owner){ .... ///get device pairing information }else if(newNode.path.contains(':devicesPairing')){ logger.i('got event devicesPairing => ${newNode.name}'); await getScoreAll(); await crtAggregateScore(); await updateScoreNode(Types.userScoreNodePath, Types.geigerScoreAggregate,Types.users); ///get employee pairing information }else if(newNode.path.contains(':employeesPairing')){ logger.i('got event employeesPairing => ${newNode.name}'); await getScoreAll(); await getEmployeesSharedScore(); await crtAggregateScore(); await updateScoreMSENode(); } .... } } ------------------------------ ///Preparation Aggregate Score (Total Score) from User, Device Nodes ///To check current User, Device Node and Pairing Node (shared my another device score) Future getScoreAll() async{ ///Prevent duplication CoreValues.aggregate.clear(); CoreValues.aggregateThreatsScore = ''; ///For shared threat score from another my device score var sharedthreatsScoreList = []; ///For current device my threat scores var currentThreatsScoreList = []; try { ///Get current all information of device, user risk score currentThreatsScoreList = await getCurrentScore(); logger.d('indiC getScore threatsScoreAggregate getCurrentScore $currentThreatsScoreList'); ///Sum threat risk score from current device, user score for(var i = 0; i < CoreValues.geigerThreatUUID.length; i++){ var tempDevice = currentThreatsScoreList[0][i].split(','); var tempUser = currentThreatsScoreList[1][i].split(','); var score = (double.parse(tempDevice[1])+double.parse(tempUser[1]))/2; CoreValues.aggregateThreatsScore += '${tempDevice[0]},$score;'; } try { ///Get shared risk score of another my device ///regarding sharing information to check on GEIGER wiki var devicesPairingNode = await Storage.controller.get(':Enterprise:Users:${Storage.userUUID}:devicesPairing'); var getChildren = await devicesPairingNode.getChildren(); var devicesIterator = getChildren.entries.iterator; ///Check shared risk score of another my devices (0...*) ///Based on GEIGER wiki while (devicesIterator.moveNext()) { // var userNameNode = await devicesIterator.current.value.getValue('userName'); // var useruuidNode = await devicesIterator.current.value.getValue('userUUID'); // var devicenameNode = await devicesIterator.current.value.getValue('deviceName'); var sharedGEIGERScoreNode = await devicesIterator.current.value.getValue('sharedGeigesharedThreatsScorerScore'); var sharedThreatsScoreNode = await devicesIterator.current.value.getValue(''); var sharedNumberOfMetricNode = await devicesIterator.current.value.getValue('sharedNumberOfMetric'); // var sharedScoreDateNode = await devicesIterator.current.value.getValue('sharedScoreDate'); // var username = userNameNode!.getValue('en'); // var useruuid = useruuidNode!.getValue('en'); // var devicename = devicenameNode!.getValue('en'); var sharedGEIGERScore = sharedGEIGERScoreNode!.getValue('en'); var sharedThreatsScore = sharedThreatsScoreNode!.getValue('en'); var sharedNumberOfMetric = sharedNumberOfMetricNode!.getValue('en'); // var sharedScoreDate = sharedScoreDateNode!.getValue('en'); var tempSharedThreatsScore = sharedThreatsScore!.split(';'); sharedthreatsScoreList.add(tempSharedThreatsScore); ///Makes Map {Risk Score: Number of Metric} ///this store at global value 'CoreValues.aggregate' var tempMap = {}; tempMap[sharedGEIGERScore] = sharedNumberOfMetric; CoreValues.aggregate.add(tempMap); } ///Sum shared risk threat score from shared devices for(var threatsScoreAggregate in sharedthreatsScoreList ){ for(var i = 0; i < CoreValues.geigerThreatUUID.length; i++){ var tempTSA = threatsScoreAggregate[i].split(','); var score = double.parse(tempTSA[1]); CoreValues.aggregateThreatsScore += '${tempTSA[0]},$score;'; } } } on StorageException { logger.i(\"Doesn't exists your Pairing devices, Please pair your devices\"); } }catch (e){ logger.i('indiA getScore ${e.toString()}'); } }","title":"Getting pairing data"},{"location":"testcase/SMEscoreCalculation/","text":"MSE Score Calculation (company total risk score) given prepared Local Data Storage instance to access Local Data Storage. prepared GEIGER data (metrics, recommendation, pairing) from external plugin. current physics device owner is company owner (CEO). when call the updateScoreMSENode() function to calculate the SME risk score, update the risk node on local data storage then get aggregate risk score of employees on getEmployeesSharedScore() function. calculate total risk score refer prepared metrics on crtAggregateScore() function. update SME risk score node on Local data Storage . ///update geiger MSE score node ///it required employee pairing and main user (CEO) Future updateScoreMSENode() async { try { if (CoreValues.flagMainUser) { var scoreMSENode = await Storage.controller.get(':Enterprise:'+ Storage.geigerIndicatorUUID +':data:GeigerScoreMSE'); scoreMSENode.owner = Types.owner; ///create node keys: UserScore, ImplementRecommendations /// ignore: non_constant_identifier_names NodeValue GEIGERScore = NodeValueImpl('GEIGER_score', CoreValues.gagg.toString()); //add node name (name of threat) scoreMSENode.updateValue(GEIGERScore); NodeValue location = NodeValueImpl('location', CoreValues.enterpriseNode['location']); scoreMSENode.updateValue(location); NodeValue associatedProfiles = NodeValueImpl('associatedProfiles', CoreValues.enterpriseNode['associatedProfiles']); scoreMSENode.updateValue(associatedProfiles); await Storage.controller.addOrUpdate(scoreMSENode); logger.i('UPDATE GeigerScoreMSE Node => ${await Storage.controller.dump(':Enterprise:'+ Storage.userUUID + ':'+ Storage.geigerIndicatorUUID +':data:GeigerScoreMSE')}'); } } catch (e) { logger.e(e); } }","title":"SME Score Calculation"},{"location":"testcase/prepareProfile/","text":"Prepare metrics about company profile(type) => (based, enabler, dependent) given prepared Local Data Storage instance to access Local Data Storage. when call getProfiles() function to parsing :Global:profiles . then get profile data from :Global:profiles node. parsing to profile data to Map<key,value> in variables.dart . ///Get global profile data ///it is static from cloud and cyber security institute ///define threat value base on company type (based, enabler, dependent) ///** threat uuid in global profile is match to global threat uuid ** ///** that mean uuid of global threat is static, fixed ** Future getProfiles() async { const path = ':Global:profiles'; try{ Node profilesNode = await Storage.controller.get(path); var getChildren = await profilesNode.getChildren(); var profileNodeIterator = getChildren.entries.iterator; ///Get each company type (based, enabler, dependent) while (profileNodeIterator.moveNext()) { var nameNode = await profileNodeIterator.current.value.getValue('name'); var profileName = nameNode!.getValue('en')!.toLowerCase(); //Profile UUID\uc640 Theat UUID \uac19\uc740 \ub188\uaec4\ub85c \ub2e4\ub978 \uc774\ub984 \uac19\uc740 \uac83\ub3c4 \uac19\uc740 \uac12\uc744 \uac00 for(var m in CoreValues.threatUUIDGeigerName.entries){ ///Get value of threat in company type using Global threat uuid ///m.key => global threat uuid (12) ///m.value => value for metrics var metrics = await profileNodeIterator.current.value.getValue(m.key); if(metrics != null){ if(!CoreValues.geigerThreatUUID.contains(m.key)){ CoreValues.geigerThreatUUID.add(m.key); CoreValues.geigerThreatNameThreatUUID[m.value] = m.key; CoreValues.geigerThreatUUIDThreatName[m.key] = m.value; } ///get threat uuid list using geiger name var normalThreatUUIDList = CoreValues.geigerNameThreatUUID[m.value]; await storeV(profileName, metrics, normalThreatUUIDList); } } } logger.d('geigerThreatUUID => ${CoreValues.geigerThreatUUID}'); logger.d('geigerThreatNameThreatUUID => ${CoreValues.geigerThreatNameThreatUUID}'); logger.d('geigerThreatUUIDThreatName => ${CoreValues.geigerThreatUUIDThreatName}'); logger.d('based => ${CoreValues.based}'); logger.d('enabler => ${CoreValues.enabler}'); logger.d('dependent => ${CoreValues.dependent}'); } on StorageException{ logger.i('$path does not exist'); } catch (e){ logger.e(e); } }","title":"Prepare global profiles"},{"location":"testcase/prepareRecommendation/","text":"Prepare metrics about recommendation each threat given prepared Local Data Storage instance to access Local Data Storage. when call getRecommendation() function to parsing :Global:profiles . then get profile data from :Global:recommendation node. parsing to profile data to Map<key,value> in variables.dart . ///Making Map<String, List<Map>> user, device Recommendation ///Parsing global recommendation metrics /// key => global threat UUID unique (12) /// value => recommendation Map List /// recommendation Map List => [{metric, recommendation UUID},....] Future getRecommendation() async { const path = ':Global:Recommendations'; try { ///Get all global recommendation List ///this is static from cloud var recommendationNode = await Storage.controller.get(path); var getChildren = await recommendationNode.getChildren(); var recoStrList = await recommendationNode.getChildNodesCsv(); var recoList = recoStrList.split(','); logger.d('reco List => $recoList'); var recoNodeIterator = getChildren.entries.iterator; ///loop each recommendation Node while (recoNodeIterator.moveNext()) { var recommendationTypeNode = await recoNodeIterator.current.value.getValue('RecommendationType'); var recommendationType = recommendationTypeNode!.getValue('en')!; logger.d('a$recommendationType'); var relatedThreatsWeightsNode = await recoNodeIterator.current.value.getValue('relatedThreatsWeights'); //logger.d('b$relatedThreatsWeightsNode'); var metricThreats = relatedThreatsWeightsNode!.getValue('en')!.split(';'); //List<String> logger.d('c$metricThreats'); for (var metricNode in metricThreats) { ///{'threatUUID,metricValue({'high', 'medium', 'low'}) ///metric[0] => threatUUID ///metric[1] => metric {'high' or 'medium' or 'low'} var metric = metricNode.split(','); logger.d('>>>$metric'); var metricRecoUUID = {}; metricRecoUUID['metric'] = metric[1]; metricRecoUUID['recoUUID'] = recoNodeIterator.current.key; if (recommendationType == Types.recoTypeDevice) { try { if(metric[0].isNotEmpty) CoreValues.deviceRecommendation[metric[0]]!.add(metricRecoUUID); } catch (e) { var temp = <Map>[]; temp.add(metricRecoUUID); CoreValues.deviceRecommendation[metric[0]] = temp; } } else { try { if(metric[0].isNotEmpty) CoreValues.userRecommendation[metric[0]]!.add(metricRecoUUID); } catch (e) { var temp = <Map>[]; temp.add(metricRecoUUID); CoreValues.userRecommendation[metric[0]] = temp; } } } } logger.d('userRecommendation => ${CoreValues.userRecommendation}'); logger.d('deviceRecommendation => ${CoreValues.deviceRecommendation}'); } on StorageException{ logger.e('$path does not exist, please check your global data'); } catch (e) { logger.e(e); } }","title":"prepareRecommendation"},{"location":"testcase/scoreCalculation/","text":"Score Calculation (User, Device, Calculation) given prepared Local Data Storage instance to access Local Data Storage. prepared GEIGER data (metrics, recommendation, pairing) from external plugin. when call the updateScoreNode() function to calculate the risk score, update risk node on local data storage then calculate risk score each threat on crtThreatScore() function. calculate total risk score on crtTotalThreatScore() function. update geiger score node on Local data Storage . ///update geiger score node (user, device, aggregate) ///To get metrics (external plugin, recommendations) Future updateScoreNode(var path, var nodeName,var type) async { try{ Node scoreNode = await Storage.controller.get('$path$nodeName'); scoreNode.owner = Types.owner; var geigerScore = 0.0; ///Calculate risk score each geiger threats (12) ///Based on metric of external plugin and recommendations NodeValue geigerThreatScores = NodeValueImpl('threats_score', nodeName == Types.geigerScoreAggregate ? CoreValues.aggregateThreatsScore : await crtThreatScore(type)); await scoreNode.updateValue(geigerThreatScores); ///Calculate geiger total risk score based on indicator algorithm - refer user, device, recommendation nodeName == Types.geigerScoreAggregate ? geigerScore = CoreValues.gagg : geigerScore = double.parse(await crtTotalThreatScore(type)); NodeValue geigerScoreNode = NodeValueImpl('GEIGER_score', geigerScore.toString()); await scoreNode.updateValue(geigerScoreNode); ///Calculate number of metric to used on risk score num len = 0; if(type == Types.users){ var temp = {}; temp.addAll(CoreValues.userPositive); temp.addAll(CoreValues.userNegative); for(var e in temp.entries){ len += e.value.length; } len += CoreValues.uuidUserImplementedRecommendations.length; }else{ var temp = {}; temp.addAll(CoreValues.devicePositive); temp.addAll(CoreValues.deviceNegative); for(var e in temp.entries){ len += e.value.length; } len += CoreValues.uuidDeviceImplementedRecommendations.length; } var numberMetrics = ''; nodeName == Types.geigerScoreAggregate ? numberMetrics = CoreValues.nagg : numberMetrics = len.toString(); NodeValue geigerNumMetrics = NodeValueImpl('number_metrics', numberMetrics); await scoreNode.updateValue(geigerNumMetrics); ///If type is user, device score (TRUE) if (nodeName != Types.geigerScoreAggregate) { var implementedRecommendationsReco = ''; type == Types.users ? implementedRecommendationsReco = CoreValues.uuidUserImplementedRecommendations.toString().replaceAll('[','').replaceAll(']','').trim() : implementedRecommendationsReco = CoreValues.uuidDeviceImplementedRecommendations.toString().replaceAll('[','').replaceAll(']','').trim(); NodeValue implementedRecommendations = NodeValueImpl('implementedRecommendations',implementedRecommendationsReco); await scoreNode.updateValue(implementedRecommendations); await Storage.controller.addOrUpdate(scoreNode); logger.i('UPDATE $nodeName Node => ${await Storage.controller.dump('$path$nodeName')}'); } ///If type is aggregate score (total score) (FALSE) else { await Storage.controller.addOrUpdate(scoreNode); logger.i('UPDATE $nodeName Node => ${await Storage.controller.dump('$path$nodeName')}'); } }on StorageException{ logger.e('data does not exist'); } catch (e){ logger.e(e); } }","title":"User/Device/Aggregate Score"}]}